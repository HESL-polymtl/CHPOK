#******************************************************************
#
# Institute for System Programming of the Russian Academy of Sciences
# Copyright (C) 2016 ISPRAS
#
#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, Version 3.
#
# This program is distributed in the hope # that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
# See the GNU General Public License version 3 for more details.
#
#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

"""
misc/SConscript

Depended on 'mode' parameter, provide targets for build either
whole module or a single partition.
In the case of the module additional commands are created for run this
module or debug it.
"""

# Import()s environment 'env'. It must contain variables:
#
# - 'BSP' - board specified for build JetOS against it.
#
# Also, imported environment may contain variables:
#
# - 'jdeveloper' - if set to True, it enables JetOS developer mode.
# In this mode some additional JetOS files may be (re)generated.
# By default, these files are already existed.
#
# - 'cdeveloper' - if set to True, it enables component developer mode
# in system partitions. In this mode some additional files for such
# partitions may be (re)generated. By default, these files are already
# existed.
#
# - 'GDB' - gdb executable for use instead of one provided in
# bsp-definition script (see below).
#
# - 'PREFIX' - prefix of toolchain for use instead of one provided in
# bsp-definition script (see below).
#
# - 'QEMU' - qemu executable for use instead of one provided in
# bsp-definition script (see below).
#
#
# Then environment is filled with global, arch-independent parameters.
#
# Then env['BSP'] value is used for call bsp-definition script located
# at misc/boards/<BSP>/SConscript and 'env' is passed to it.
#
# Then 'Import()'s 'mode' variable.
#
# If value of 'mode' variable is equal to 'module', executes script
# 'SConscript_module' passing environment ('env') to it.
#
# If value of 'mode' variable is equal to 'partition', executes script
# 'SConscript_partition' passing partition's environment ('part_env') to it.

import sys
import os

Import('env')

jetos_home = Dir('..').abspath # Do not require os environment variable JETOS_HOME

env['JETOS_HOME'] = jetos_home
env['LAUNCHDIR'] = GetLaunchDir()

log_file_opened = False

# This tells scons to store all file signatures
# in a separate .sconsign file in each directory
SConsignFile(None)

# Cache built files
#CacheDir(env['JETOS_HOME']+'/cache')

if ARGUMENTS.get('VERBOSE') != "1":
    env['CCCOMSTR'] = "CC $TARGET",
    env['LINKCOMSTR'] = "LD $TARGET"
    env['ARCOMSTR'] = "AR $TARGET"
    env['ASCOMSTR'] = "AS $TARGET"
    env['ASPPCOMSTR'] = "AS $TARGET"
    env['RANLIBCOMSTR'] = "RANLIB $TARGET"
    env['SIZES_C_GEN_COMSTR'] = "GENERATE $TARGET"
    env['SIZES_O_CREATE_COMSTR'] = "CREATE $TARGET"
    env['JINJACOMSTR'] = "JINJA generate $TARGET"
    env['MERGE_PARTITIONS_COMSTR'] = "MERGE PARTITIONS $TARGET"
    env['CONF_TOTAL_COMSTR'] = "generate total configuration $TARGET"
    env['MEMORY_CONSTRAINTS_COMSTR'] = "create memory constraints $TARGET"
    env['ARCH_DEPLOY_FUNC_COMSTR'] = "Arch creates memory mapping: $TARGETS"
    env['GDB_COMMANDS_COMSTR'] = "Generate GDB_commands file $TARGET"


# Flags common for all architectures
# Linker flags for '.lo' objects, but not for '.elf'
env['LINKFLAGS'] = '-r'
env.Append(QEMU_FLAGS = ' -serial stdio')
# 16 MBytes
env['MAX_PART_SIZE'] = 16 * 2**20

env['CFLAGS'] = '-std=gnu99 -iwithprefix include -Wall -Wuninitialized -ffreestanding -nostdlib -nostdinc -g '
env['ASFLAGS'] = env['CFLAGS']
env['CFLAGS_KERNEL'] = ''

# Store variables which may be redefined by the caller script.
preset_var_names = ['PREFIX', 'GDB', 'QEMU']
preset_vars = {name: env.get(name, None) for name in preset_var_names}

# Execute bsp-definition script
bsp_definition_script = os.path.join(env['JETOS_HOME'], 'misc/boards', env['BSP'], 'SConscript')
if not os.path.isfile(bsp_definition_script):
    print "ERROR: There is no bsp-definition script '" + bsp_definition_script + "'"
    print "HINT: Probably, bsp=" + env['BSP'] + " is not supported yet."
    Exit(1)

SConscript(bsp_definition_script, exports = 'env')

# Restore variables which may be redefined by the caller script
for name in preset_var_names:
    var = preset_vars[name]
    if var is not None:
        env[name] = var

# Make sure that 'BOARD_IS_EMULATED' variable is defined
if not 'BOARD_IS_EMULATED' in env:
    env['BOARD_IS_EMULATED'] = False

if not 'BOARD_PHYS_SIZE' in env and 'BOARD_IS_EMULATED' in env:
    env['BOARD_PHYS_SIZE'] = 2**27 #default value for QEMU


if not 'BOARD_PHYS_SIZE' in env:
    print "ERROR: Board '%s' doesn't set BOARD_PHYS_SIZE variable." % env['BSP']
    print "This is an error of board developers."
    Exit(1)

env['KERNEL_CPPPATH'] = [
    env['JETOS_HOME']+'/kernel/include',
    env['JETOS_HOME']+'/kernel/arch/' + env['ARCH'] + '/include',
    env['JETOS_HOME']+'/boards/' + env['BSP'] + '/include',
]

env['LIBPOK_CPPPATH'] = [
    env['JETOS_HOME']+'/libpok/include',
    env['JETOS_HOME']+'/libpok/arch/' + env['ARCH'] + '/include',
]

# These depend only on prefix
env['AR']      = env['PREFIX'] + 'ar'
env['CC']      = env['PREFIX'] + 'gcc'
env['LINK']    = env['PREFIX'] + 'ld'
env['OBJCOPY'] = env['PREFIX'] + 'objcopy'
env['OBJDUMP'] = env['PREFIX'] + 'objdump'
env['RANLIB']  = env['PREFIX'] + 'ranlib'

# 'GDB' may be already set by the caller or by bsp-definition.
# So check it before set according to the prefix.
gdb_val = env.get('GDB', None)
if gdb_val is None:
    env['GDB'] = env['PREFIX'] + 'gdb'

env['LIBGCC'] = os.popen(env['CC']+' -print-libgcc-file-name').read().replace('\n', '')

env['TYPES_REQUIREMENTS_YAML'] = jetos_home + '/misc/types_requirements/generic_types_requirements.yaml'

def KernelEnvironment(env):
    """
    Create fresh kernel environment from the main one.
    """
    kernel_env = env.Clone()
    kernel_env['CPPPATH'] = env['KERNEL_CPPPATH']
    kernel_env.Append(CFLAGS = ' ' + env.get('CFLAGS_KERNEL', default = ''))
    return kernel_env

def PartitionEnvironment(env):
    """
    Create fresh partition's environment from the main one.
    """
    part_env = env.Clone()
    part_env['CPPPATH'] = env['LIBPOK_CPPPATH']
    part_env.Append(CFLAGS = ' -include '+ part_env['JETOS_HOME']+'/libpok/include/config.h')
    return part_env

env.AddMethod(KernelEnvironment)
env.AddMethod(PartitionEnvironment)

def RemoveDirectories(env, target, dirs):
    """
    Create target $target which removes given directories, if them exist.
    """
    if type(dirs) is not list:
        dirs = [dirs]

    # Currently command line for all scons commands is unconditionally replaced
    # in print_cmd_line().
    # So do not bother with pretty command line of given command.
    return env.Command(target, [], Delete(dirs))

env.AddMethod(RemoveDirectories)

# Return absolute version of the 'path', which may be instance of
# SCons.Node.Node or a string.
#
# If given path is instance of SCons.Node.Node, or it is a string which
# starts with '/' or '#', return path object unchanged.
#
# Otherwise, return path prepended with (base_dir + '/').
def toAbsPath(env, path, base_dir):
    if not type(path) is str:
        pass
    elif path.startswith('/') or path.startswith('#'):
        pass
    else:
        path = base_dir + '/' + path

    return path

env.AddMethod(toAbsPath)

# Accept list of paths, each of which may be either instance of
# SCons.Node.Node or string.
#
# Return list, in which all paths are absolute.
#
# If 'paths' is actually a single path (not a list), it is treated
# as a list with a single element. (Returning value is always a list).
def toAbsPathList(env, paths, base_dir):
    if type(paths) is not list:
        paths = [paths]
    return [env.toAbsPath(path, base_dir) for path in paths]

env.AddMethod(toAbsPathList)

class SharedTargets:
    """
    Dictionary object which remains the same after cloning and importing
    environment. That is, modification of that object in one cloned environment
    is visible in another cloned environment.
    """
    def __init__(self):
        self.names = dict()

env['SHARED_TARGETS'] = SharedTargets()

def getSharedTarget(env, name, compute_val):
    """
    Return object from shared area of environment.
    If object doesn't exist yet, compute it.

    Such a way, the object will be computed only once.

    Usually, object is a SCons *target* (that is, list of 'Node' objects).
    """
    val = env['SHARED_TARGETS'].names.get(name, None)
    if val is None:
        val = compute_val()
        env['SHARED_TARGETS'].names[name] = val
    return val

env.AddMethod(getSharedTarget)

if env.get('jdeveloper'):
    # Fake command for suppress "Nothing to be done" for alias target.
    env.Command('regenerate-command', [], "")
    env.Alias('regenerate', 'regenerate-command')

Import('mode')

if mode == 'module':
    mod_elf = SConscript('SConscript_module', exports = 'env')
    Default(mod_elf)
    ret_env = env
elif mode == 'partition':
    part_env = env.PartitionEnvironment()
    part_elf = SConscript('SConscript_partition', exports = 'part_env')
    Default(part_elf)
    ret_env = part_env
else:
    print "Error: Invalid value for 'mode' parameter for the main SConscript: " + str(mode)
    print "Should be 'module' or 'partition'."
    raise RuntimeError("Invalid 'mode' parameter")
