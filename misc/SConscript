#******************************************************************
#
# Institute for System Programming of the Russian Academy of Sciences
# Copyright (C) 2016 ISPRAS
#
#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, Version 3.
#
# This program is distributed in the hope # that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
# See the GNU General Public License version 3 for more details.
#
#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

"""
misc/SConscript

Depended on 'mode' parameter, provide targets for build either
whole module or a single partition.
In the case of the module additional commands are created for run this
module or debug it.
"""

# Import()s environment 'env'. It must contain variables:
#
# - 'BSP' - board specified for build JetOS against it.
#
# Also, imported environment may contain variables:
#
# - 'jdeveloper' - if set to True, it enables JetOS developer mode.
# In this mode some additional JetOS files may be (re)generated.
# By default, these files are already existed.
#
# - 'cdeveloper' - if set to True, it enables component developer mode
# in system partitions. In this mode some additional files for such
# partitions may be (re)generated. By default, these files are already
# existed.
#
# - 'GDB' - gdb executable for use instead of one provided in
# bsp-definition script (see below).
#
# - 'PREFIX' - prefix of toolchain for use instead of one provided in
# bsp-definition script (see below).
#
# - 'QEMU' - qemu executable for use instead of one provided in
# bsp-definition script (see below).
#
#
# Then environment is filled with global, arch-independent parameters.
#
# Then env['BSP'] value is used for call bsp-definition script located
# at boards/<BSP>/SConscript and 'env' is passed to it.
#
# This bsp-definition script should/may fill environment variables:
# 
# - 'ARCH' - target architecture, corresponded to given BSP.
# (String, required).
#
# - 'PREFIX' - prefix of toolchain tools used for compile, link, etc.
# If variable has been when current script is called (see above), it
# will restore the first value.
# (String, required).
#
# - 'GDB' - gdb executable for debug. If absent, PREFIX'ed version is used.
# If variable has been when current script is called (see above), it
# will restore the first value.
# (String/path, optional).
#
# - 'QEMU' - qemu executable for run.
# If variable has been when current script is called (see above), it
# will restore the first value.
# (String/path, required).
#
# - 'QEMU_FLAGS' - flags for run qemu.
# (Space-separated string, required).
#
# - 'CFLAGS' - may append additional flags for compile "C" sources.
#
# - 'CFLAGS_KERNEL' - may append additional flags for compile "C" sources
# for kernel space.
#
# - 'AFLAGS' - may append additional flags for compile asm sources.
#
#
# Then 'Import()'s 'mode' variable.
#
# If value of 'mode' variable is equal to 'module', 'Import()'s variable
# 'module_def' and execute script 'SConscript_module', passing this
# variable to it alongside with the environment ('env').
#
# If value of 'mode' variable is equal to 'partition', 'Import()'s variable
# 'partition_def' and execute script 'SConscript_partition' passing this variable
# to it alongside with the partition's environment ('part_env').

import sys
import os

Import('env')

def print_cmd_line(s, target, src, env):
    # s is the original command line, target and src are lists of target
    # and source nodes respectively, and env is the environment.
    global log_file_opened
    if not log_file_opened and str(target[0]) != 'run':
        open(env['LAUNCHDIR']+'/scons_build.log', 'w')
        log_file_opened = True

    if str(target[0]) != 'run':
        with open(env['LAUNCHDIR']+'/scons_build.log', 'a') as log:
                log.write("%s\n"%s)

    # For now len is always 1
    if len(target) == 1:
        x = str(target[0])
        sys.stdout.write("%s ...\n" % os.path.relpath(x, start=env['JETOS_HOME']))
    else:
        sys.stdout.write("Making %s...\n" %(' and '.join([str(x) for x in target])))

jetos_home = Dir('..').abspath # Do not require os environment variable JETOS_HOME

env['JETOS_HOME'] = jetos_home
env['LAUNCHDIR'] = GetLaunchDir()

log_file_opened = False

# This tells scons to store all file signatures 
# in a separate .sconsign file in each directory
SConsignFile(None)

# Cache built files
#CacheDir(env['JETOS_HOME']+'/cache')

# Flags common for all architectures
env['PRINT_CMD_LINE_FUNC'] = print_cmd_line
# Linker flags for '.lo' objects, but not for '.elf'
env['LINKFLAGS'] = '-r'
env['QEMU_FLAGS'] = ' -serial stdio'
# 16 MBytes
env['MAX_PART_SIZE'] = 16 * 2**20

env['CFLAGS'] = '-std=gnu99 -iwithprefix include -Wall -Wuninitialized -ffreestanding -nostdlib -nostdinc -g '
env['ASFLAGS'] = env['CFLAGS']
env['CFLAGS_KERNEL'] = ''

# Store variables which may be redefined by the caller script.
preset_var_names = ['PREFIX', 'GDB', 'QEMU']
preset_vars = {name: env.get(name, None) for name in preset_var_names}

# Execute bsp-definition script
bsp_definition_script = os.path.join(env['JETOS_HOME'], 'misc/boards', env['BSP'], 'SConscript')
if not os.path.isfile(bsp_definition_script):
	print "ERROR: There is no bsp-definition script '" + bsp_definition_script + "'"
	print "HINT: Probably, bsp=" + env['BSP'] + " is not supported yet."
	Exit(1)

SConscript(bsp_definition_script, exports = 'env')

# Restore variables which may be redefined by the caller script
for name in preset_var_names:
	var = preset_vars[name]
	if var is not None:
		env[name] = var

env['KERNEL_CPPPATH'] = [
    env['JETOS_HOME']+'/kernel/include',
    env['JETOS_HOME']+'/kernel/arch/' + env['ARCH'] + '/include',
    env['JETOS_HOME']+'/boards/' + env['BSP'] + '/include',
]

env['LIBPOK_CPPPATH'] = [
    env['JETOS_HOME']+'/libpok/include',
    env['JETOS_HOME']+'/libpok/arch/' + env['ARCH'] + '/include',
]

# These depend only on prefix
env['AR']      = env['PREFIX'] + 'ar'
env['CC']      = env['PREFIX'] + 'gcc'
env['LINK']    = env['PREFIX'] + 'ld'
env['OBJCOPY'] = env['PREFIX'] + 'objcopy'
env['OBJDUMP'] = env['PREFIX'] + 'objdump'
env['RANLIB']  = env['PREFIX'] + 'ranlib'

# 'GDB' may be already set by the caller or by bsp-definition.
# So check it before set according to the prefix.
gdb_val = env.get('GDB', None)
if gdb_val is None:
    env['GDB'] = env['PREFIX'] + 'gdb'

env['LIBGCC'] = os.popen(env['CC']+' -print-libgcc-file-name').read().replace('\n', '')

def KernelEnvironment(env):
	"""
	Create fresh kernel environment from the main one.
	"""
	kernel_env = env.Clone()
	kernel_env['CPPPATH'] = env['KERNEL_CPPPATH']
	kernel_env.Append(CFLAGS = ' ' + env.get('CFLAGS_KERNEL', default = ''))
	return kernel_env

def PartitionEnvironment(env):
	"""
	Create fresh partition's environment from the main one.
	"""
	part_env = env.Clone()
	part_env['CPPPATH'] = env['LIBPOK_CPPPATH']
	part_env.Append(CFLAGS = ' -include '+ part_env['JETOS_HOME']+'/libpok/include/config.h')
	return part_env

env.AddMethod(KernelEnvironment)
env.AddMethod(PartitionEnvironment)

def RemoveDirectories(env, target, dirs):
	"""
	Create target $target which removes given directories, if them exist.
	"""
	if type(dirs) is not list:
		dirs = [dirs]

	# Currently command line for all scons commands is unconditionally replaced
	# in print_cmd_line().
	# So do not bother with pretty command line of given command.
	return env.Command(target, [], Delete(dirs))

env.AddMethod(RemoveDirectories)

# Return absolute version of the 'path', which may be instance of
# SCons.Node.Node or a string.
#
# If given path is instance of SCons.Node.Node, or it is a string which
# starts with '/' or '#', return path object unchanged.
#
# Otherwise, return path prepended with (base_dir + '/').
def toAbsPath(env, path, base_dir):
	if not type(path) is str:
		pass
	elif path.startswith('/') or path.startswith('#'):
		pass
	else:
		path = base_dir + '/' + path

	return path

env.AddMethod(toAbsPath)

# Accept list of paths, each of which may be either instance of
# SCons.Node.Node or string.
#
# Return list, in which all paths are absolute.
#
# If 'paths' is actually a single path (not a list), it is treated
# as a list with a single element. (Returning value is always a list).
def toAbsPathList(env, paths, base_dir):
	if type(paths) is not list:
		paths = [paths]
	return [env.toAbsPath(path, base_dir) for path in paths]

env.AddMethod(toAbsPathList)

Import('mode')

# Libpok is needed for any partition.
env['LIBPOK_TARGET'] = SConscript(env['JETOS_HOME'] + '/libpok/SConscript',
	exports = 'env',
	variant_dir = env['JETOS_HOME'] + '/build/'+env['BSP']+'/libpok',
	duplicate = 0
)
# Syspart may be needed for some partition.
# If it is not, the target just isn't built.
env['SYSPART_TARGET'] = SConscript(env['JETOS_HOME'] + '/syspart/SConscript',
	exports = 'env',
	variant_dir = env['JETOS_HOME'] + '/build/'+env['BSP']+'/syspart',
	duplicate = 0
)

if mode == 'module':
    mod_elf = SConscript('SConscript_module', exports = 'env')
    Default(mod_elf)
    ret_env = env
elif mode == 'partition':
    part_env = env.PartitionEnvironment()
    part_elf = SConscript('SConscript_partition', exports = 'part_env')
    Default(part_elf)
    ret_env = part_env
else:
    print "Error: Invalid value for 'mode' parameter for the main SConscript: " + str(mode)
    print "Should be 'module' or 'partition'."
    raise RuntimeError("Invalid 'mode' parameter")

if env.get('jdeveloper'):
    # Fake command for suppress "Nothing to be done" for alias target.
    env.Command('regenerate-command', [], "")
    env.Alias('regenerate', 'regenerate-command')


clean_directories = [env['JETOS_HOME'] + '/build']

env.RemoveDirectories('clean_os_cmd', clean_directories)
env.Alias('distclean', 'clean_os_cmd')
env.Clean('#/all', clean_directories)
# EOF
