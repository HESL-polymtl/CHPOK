#******************************************************************
#
# Institute for System Programming of the Russian Academy of Sciences
# Copyright (C) 2016 ISPRAS
#
#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, Version 3.
#
# This program is distributed in the hope # that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
# See the GNU General Public License version 3 for more details.
#
#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

"""
Environment definitions for MIPS architecture.
"""

from __future__ import division

import os
import memory_definition
import template_generation
import math
from board_deploy_simple import *
from text_serialization import *

Import('env')

env['PREFIX'] = 'mips-linux-gnu-'

env['QEMU'] = '~/workspace/Niisi/niisi/qemu/mips64-softmmu/qemu-system-mips64'

env.Append(CFLAGS = '')
env.Append(ASFLAGS = '')

env.Append(CFLAGS_KERNEL = '')

env['LDSCRIPT_KERNEL'] = env['JETOS_HOME'] + '/kernel/arch/mips/ldscripts/kernel.lds'
env['LDSCRIPT_PARTITION'] = env['JETOS_HOME'] + '/kernel/arch/mips/ldscripts/partition.lds'

arch_dir = Dir('.').srcnode().abspath

# Below is an implementation of arch deployment functionality.
def align_val(val, align):
    return ((val + align - 1) // align) * align

class TLBEntry(SerializableObject):
    yaml_tag = '!MIPSTLBEntry'

    copy_slots = [
        'vaddr',
        'paddr',
        'size_enum',
        'permissions',
        'cache_policy',
        'pid'
    ]

    # In accordance with MIPS_PGSIZE_* constants
    # defined in kernel/arch/mips/include/arch/mmu_ext.h.
    size_enum_values = ['4K', '16K', '64K', '256K', '1M', '4M', '16M']

    def __init__(self, **kargs):
        copy_constructor(self, kargs)

    @classmethod
    def permissions_from_access(cls, access):
        """
        For given 'access' string return permissions for TLB entry.
        """
        permissions = "EntryLo_V | EntryLo_D" # RW from the kernel

        #~ if 'R' in access:
            #~ permissions += " | EntryLo_V"
        #~ if 'W' in access:
            #~ permissions += " | EntryLo_D"
        #~ if 'X' in access:
            #~ permissions += " | MAS3_UX"

        return permissions

    @classmethod
    def cache_policy_val(cls, cache_policy):
        """
        For cache_policy string return its integer representation.
        """
        # Currently only default cache policy is supported.
        if cache_policy == "DEFAULT":
            return "0"
        elif cache_policy == "IO":
            #~ FIXIT!!!!
               return "0"
            #~ return "MAS2_W | MAS2_I | MAS2_M | MAS2_G" # WRITE_TROUGH(redundand)+Cache_OFF+GUARDED+COHERENCY


class PhysMemoryBlockMIPS(PhysMemoryBlock):
    __slots__ = [
        'size_enum'
    ]

    def __init__(self, paddr, size, align, size_enum):
        PhysMemoryBlock.__init__(self, paddr, size, align)
        self.size_enum = size_enum

    def createTLBEntry(self, vaddr, access, cache_policy, space_id):
        return TLBEntry(vaddr = vaddr,
            paddr = self.paddr,
            size_enum = self.size_enum,
            permissions = TLBEntry.permissions_from_access(access),
            cache_policy = TLBEntry.cache_policy_val(cache_policy),
            pid = space_id
        )


class PhysMemoryTypeMIPS(PhysMemoryType):
    def isCacheSupported(self, cache_policy):
        # Currently only DEFAULT cache policy is supported.
        return cache_policy in ["DEFAULT", "IO"]

    def allocPhysBlock(self, paddr, size):
        """
        Allocate physical memory block.
        """
        if size > 2**24:
            print "Cannot allocate TLB of size greater than 16M."
            return

        if size < 4096:
            size = 4096
        size_pow_4 = int(math.ceil(math.log((size + 4095 ) // 4096, 4)))

        size_enum = TLBEntry.size_enum_values[size_pow_4]

        size_real = 4096 * 4**size_pow_4
        align_real = size_real

        paddr_real = align_val(paddr, align_real)

        return PhysMemoryBlockMIPS(
            paddr = paddr_real,
            size = size_real,
            align = align_real,
            size_enum = size_enum
        )

def mips_deploy_func_unsafe(env, target, source):
    mc = memory_definition.ModuleMemoryDefinition.load_from_file(source[0].abspath)

    memory_type = PhysMemoryTypeMIPS()
    phys_segment = PhysSegment(
        paddr_start = 64 * 2**20,
        paddr_end = mc.phys_total,
        memory_type = memory_type,
    )

    partitionsTLB = allocateMemoryBlocksSimple(mc,
        phys_segments = [phys_segment],
        memory_type_default = memory_type,
        vaddr_start_all = 2**30 + 2**29, # Hardcoded in ldscript.
    )

    # All TLB entries in the single array
    tlb_entries = []
    for partitionTLB in partitionsTLB:
        tlb_entries.extend(partitionTLB.entries)

    mc.save_to_file(target[0].abspath)

    serialize_as_text(tlb_entries, target[1].abspath, 'entries')

def mips_deploy_func(env, target, source):
    # Just calls mips_deploy_func_unsafe and catch exceptions
    try:
        mips_deploy_func_unsafe(env, target, source)
    except RuntimeError as e:
        print "Error occured while deploy memory blocks: %s." % e.message
        return 1

def mips_create_definitions_for_deployment(source, env):
    entries = deserialize_from_text(source[0].abspath, 'entries')

    return {'entries': entries}

def mips_deploy(env, memory_definitions_file, memory_constraints):

    arch_deployment_kernel_yaml = os.path.join(env['MODULE_BUILD_DIR'], "mips_tlb.yaml")

    env.Command(target = [memory_definitions_file, arch_deployment_kernel_yaml],
        source = memory_constraints,
        action = Action(mips_deploy_func, '$ARCH_DEPLOY_FUNC_COMSTR')
    )

    env.AddMethod(template_generation.TemplateRender)

    env['BOARD_DEPLOYMENT_SOURCES'] += env.TemplateRender(
        target = os.path.join(env['MODULE_BUILD_DIR'], "mips_tlb.c"),
        source = arch_deployment_kernel_yaml,
        create_definitions_func = mips_create_definitions_for_deployment,
        template_main = "mips_tlb_c",
        template_dir = arch_dir + "/templates"
    )

env['BOARD_DEPLOY'] = mips_deploy
