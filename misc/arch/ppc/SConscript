#******************************************************************
#
# Institute for System Programming of the Russian Academy of Sciences
# Copyright (C) 2016 ISPRAS
#
#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, Version 3.
#
# This program is distributed in the hope # that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
# See the GNU General Public License version 3 for more details.
#
#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

"""
Environment definitions for PowerPC architecture.
"""

from __future__ import division

import os
import memory_definition
import template_generation
import math
from text_serialization import *

Import('env')

env['PREFIX'] = 'powerpc-elf-'

env['QEMU'] = 'qemu-system-ppc'

env.Append(CFLAGS = ' -mregnames')
env.Append(ASFLAGS = ' -mregnames')

env.Append(CFLAGS_KERNEL = '-msoft-float')

env['LDSCRIPT_KERNEL'] = env['JETOS_HOME'] + '/kernel/arch/ppc/ldscripts/kernel.lds'
env['LDSCRIPT_PARTITION'] = env['JETOS_HOME'] + '/kernel/arch/ppc/ldscripts/partition.lds'

arch_dir = Dir('.').srcnode().abspath

# Below is an implementation of arch deployment functionality.
def align_val(val, align):
    return ((val + align - 1) // align) * align

class TLBEntry(SerializableObject):
    yaml_tag = '!PPCTLBEntry'

    copy_slots = [
        'vaddr',
        'paddr',
        'size_enum',
        'permissions',
        'cache_policy',
        'pid'
    ]

    # In accordance with E500MC_PGSIZE_* constants
    # defined in kernel/arch/ppc/include/arch/mmu_ext.h.
    size_enum_values = ['4K', '16K', '64K', '256K', '1M', '4M', '16M', '64M', '256M', '1G', '4G']

    def __init__(self, **kargs):
        copy_constructor(self, kargs)

# Simple allocator of TLB entries
class TLBEntryAllocator:
    def __init__(self, phys_start, phys_end):
        # Resulted array of TLB entries.
        self.entries = []
        self.phys_current = phys_start
        self.phys_end = phys_end

    def alloc_entry(self, vaddr, size, pid, permissions_str):
        """
        Allocate entry and add it to 'entries' array.
        Return entry allocated.

        permissions_str: String consisted of 'R', 'W', 'X'.

        Return None if failed to allocate entry (reason will be printed).
        """
        if size > 2**31:
            print "Cannot allocate TLB of size greater than 2G."
            return None

        if size < 4096:
            size = 4096
        size_pow_4 = int(math.ceil(math.log((size + 4095 ) // 4096, 4)))

        size_enum = TLBEntry.size_enum_values[size_pow_4]

        size_real = 4096 * 4**size_pow_4
        align_real = size_real

        phys_start_entry = align_val(self.phys_current, align_real)

        permissions = 0x5 # RW from the kernel

        if 'R' in permissions_str:
            permissions = permissions | 0x2
        if 'W' in permissions_str:
            permissions = permissions | 0x8
        if 'X' in permissions_str:
            permissions = permissions | 0x20

        tlb_entry = TLBEntry(vaddr = vaddr,
            paddr = phys_start_entry,
            size_enum = size_enum,
            permissions = permissions,
            cache_policy = 0,
            pid = pid)

        phys_new = phys_start_entry + size_real

        if phys_new > self.phys_end:
            print "Insufficient physical memory for add TLB entry."
            return None

        self.phys_current = phys_new

        self.entries.append(tlb_entry)

        return tlb_entry

def ppc_deploy_func(env, target, source):
    mc = memory_definition.ModuleMemoryDefinition.load_from_file(source[0].abspath)

    te_allocator = TLBEntryAllocator(
        phys_start = 64 * 2**20,
        phys_end = mc.phys_total)

    for pmc in mc.partitions:
        elf_mbd = memory_definition.MemoryBlockDefinition(
            name = '.ELF',
            size = pmc.elf_size,
            align = 2**31,
            vaddr = 2**31,
            access = "RWX"
        )

        elf_mbd.kaddr = elf_mbd.vaddr

        # Whole partition in the single TLB entry
        tlb_entry_size = elf_mbd.size
        tlb_entry_align = elf_mbd.align

        virtual_base = elf_mbd.vaddr

        for mbd in pmc.memory_blocks:
            if mbd.vaddr != None:
                print "Memory block '%s' has fixed virtual address. This feature has not been supported yet." % mbd.name
                return 1
            if mbd.is_shared:
                print "Memory block '%s' is shared. This feature has not been supported yet." % mbd.name
                return 1

            if mbd.align > tlb_entry_align:
                print "Memory block '%s' has too high alignment: %x." % (mbd.name, mbd.align)
                return 1

            tlb_entry_size = align_val(tlb_entry_size, mbd.align)

            mbd.vaddr = virtual_base + tlb_entry_size
            mbd.kaddr = mbd.vaddr

            tlb_entry_size += mbd.size

        pmc.memory_blocks.append(elf_mbd)

        te = te_allocator.alloc_entry(virtual_base, tlb_entry_size, pmc.space_id, "RWX")

        if te is None:
            return 1

    mc.save_to_file(target[0].abspath)

    serialize_as_text(te_allocator.entries, target[1].abspath, 'entries')

def ppc_create_definitions_for_deployment(source, env):
    entries = deserialize_from_text(source[0].abspath, 'entries')

    return {'entries': entries}

def ppc_deploy(env, memory_definitions_file, memory_constraints):

    arch_deployment_kernel_yaml = os.path.join(env['MODULE_BUILD_DIR'], "ppc_tlb.yaml")

    env.Command(target = [memory_definitions_file, arch_deployment_kernel_yaml],
        source = memory_constraints,
        action = ppc_deploy_func
    )

    env.AddMethod(template_generation.TemplateRender)
    arch_deployment_kernel = env.TemplateRender(
        target = os.path.join(env['MODULE_BUILD_DIR'], "ppc_tlb.c"),
        source = arch_deployment_kernel_yaml,
        create_definitions_func = ppc_create_definitions_for_deployment,
        template_main = "ppc_tlb_c",
        template_dir = arch_dir + "/templates"
    )

    env.Append(ARCH_DEPLOYMENT_KERNEL = arch_deployment_kernel)

env['ARCH_DEPLOY'] = ppc_deploy
