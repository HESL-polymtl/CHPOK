#******************************************************************
#
# Institute for System Programming of the Russian Academy of Sciences
# Copyright (C) 2016 ISPRAS
#
#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, Version 3.
#
# This program is distributed in the hope # that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
# See the GNU General Public License version 3 for more details.
#
#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

"""
Build module according to module definition script and partition definition
scripts.
"""

# This script is called from SConscript, when it builds whole module.
#
# The script Import()s variable 'env' contained main environment.
#
# Also, imported invironment should contain following variables:
#
# - 'MODULE_BUILD_DIR' - where module's elf ('pok.elf') should be built.
# (Absolute path).
#
# - 'MODULE_SOURCE_DIR' - where module sources are located.
# (Absolute path).
#
# After that, it executes SConscript located under 'MODULE_SOURCE_DIR'.
# This script is called with variant dir equal to 'MODULE_BUILD_DIR'.
#
# Then, if variable 'MODULE_POST_PROCESS' is set, it is interpreted as
# a function which accepts 'env' argument, and executed.
#
# After that, following variables, described module's components and
# configuraton, are expected to be set:
#
# - 'MODULE_CLEAN_DIRS' - which directories should be clean on `scons -c local`.
# (Absolute path or list of absolute paths; by default equal to MODULE_BUILD_DIR).
#
# - 'MODULE_XML' - xml or other file(s), from which configuration of module
# may be extracted.
# Note: per-partition 'XML' needn't be listed there.
# (Single element or list of element; element could be absolute path, relative (against source dir) or object of type 'File').
#
# - 'MODULE_PARSE_CONFIGURATION' - parser of files listed in 'XML', which should
# return object of type 'chpok_configuration.Configuration'.
# (Function with signature '(sources, env)').
#
# - 'PARTITIONS_NUMBER' - number of partitions in the module.
#
# - 'PARTITION_FILL' - function which will be called for every partition
# environment before call script 'SConscript_partition' for it.
# Index of the partition is passed to that function as the second argument.
# (That is, signature of the function is '(part_env, part_index)').
#
# Executed SConscript may modify/use scons environment variables:
#
# - CFLAGS, CPPPATH and other variables common for "C" compilation.
#   Note, that adjusting of LINKFLAGS is not supported.
#
# - QEMU_FLAGS - flags for qemu for run generated module.
#
# Also, executed SConscript may use methods:
#
# - env.PartitionEnvironment() - create fresh environment, used for
# compile things for partition(user space). E.g., one may use .Object()
# method of that environment and later add its result to
# part_env['PARTITION_SOURCES'] in 'partition_def' scripts (see below).
#
# - env.KernelEnvironment() - create fresh environment, used for
# compile things for kernel. (Note, that these things cannot be compiled
# into the module).
#
#
# After that, for every partition (of total 'PARTITION_NUMBER'):
# 1) environment for it is created,
# 2) 'PARTITION_FILL' method is called
# 3) Script 'SConscript_partition' is executed (that is, method 
#    PARTITION_FILL' should set variables required for that script).
#
# After that, target for module's creation are generated.
#
# Return target which builds module's elf.

import os
import shutil

import chpok_configuration
import template_generation

Import('env')

module_build_dir = env['MODULE_BUILD_DIR']

# Build kernel into given variant_dir.
#
# If variant_dir is not given or None, use 'kernel/' subdirectory
# in the module's build dir.
def BuildKernel(env, variant_dir = None):
    if variant_dir is None:
        variant_dir = module_build_dir+'/kernel'
    kernel_env = env.KernelEnvironment()
    return SConscript(env['JETOS_HOME'] + '/kernel/SConscript',
        exports = 'kernel_env',
        variant_dir = variant_dir,
        duplicate = 0
    )

env.AddMethod(BuildKernel)

env.SConscript(dirs = env['MODULE_SOURCE_DIR'],
    exports = 'env',
    variant_dir = module_build_dir,
    duplicate = 0)

module_post_process = env.get('MODULE_POST_PROCESS', None)
if module_post_process is not None:
    module_post_process(env)

partition_build_dirs = []
partition_clean_dirs = []
partition_xmls = []
partition_elfs = []

for part_index in range(env['PARTITIONS_NUMBER']):
    part_env = env.PartitionEnvironment()
    part_env.Append(part_index = part_index)
    env['PARTITION_FILL'](part_env, part_index)

    part_elf = SConscript('SConscript_partition', exports = 'part_env')
    partition_elfs.append(part_elf)
    partition_build_dirs.append(part_env['PARTITION_BUILD_DIR'])
    partition_clean_dirs.extend(part_env['PARTITION_CLEAN_DIRS'])
    partition_xmls.append(part_env['PARTITION_XML'])

AddMethod(env, template_generation.TemplateRender)

def get_pok_definitions(source, env):
    conf = env['MODULE_PARSE_CONFIGURATION'](source, env)
    conf.validate()
    return dict(conf = conf)


def get_pok_gdb_definitions(source, env):
    defs = dict(conf = env['MODULE_PARSE_CONFIGURATION'](source, env),
        partition_build_dirs = partition_build_dirs)

    return defs

module_xml = env.toAbsPathList(env['MODULE_XML'], env['MODULE_SOURCE_DIR'])

# Generate "deployment.c" for kernel
deployment_kernel = env.TemplateRender(
    target = os.path.join(module_build_dir, "deployment.c"),
    source = module_xml + partition_xmls,
    create_definitions_func = get_pok_definitions,
    template_main = "deployment_kernel",
    template_dir = env['JETOS_HOME'] + "/misc/templates",
    GENERATE_TITLE = template_generation.generate_title_c_no_track
    )


# Generate file with commands for GDB for possible debugging
gdb_commands = env.TemplateRender(
    target = module_build_dir + "/GDB_commands",
    source = module_xml + partition_xmls,
    create_definitions_func = get_pok_gdb_definitions,
    template_main = "GDB_commands",
    template_dir = env['JETOS_HOME'] + "/misc/templates",
    GENERATE_TITLE = template_generation.generate_title_python_no_track
    )

gdb_commands_file = gdb_commands[0].abspath

kernel_target = env.get('KERNEL_TARGET', None)
# By default, build kernel locally to the example
if kernel_target is None:
    kernel_target = env.BuildKernel()

pok_env = env.KernelEnvironment()

kernel_lo = pok_env.Program(target = module_build_dir+'/kernel.lo',
    source = kernel_target + deployment_kernel)

# there should (perhaps) also be padding to get aligned file size
def merge_partitions(target, source, env):
    with open(str(target[0]), 'wb') as part:
        for s in source:
            with open(str(s), 'rb') as orig_part:
                shutil.copyfileobj(orig_part, part)

def create_sizes_c(target, source, env):
    with open(str(target[0]), 'w') as sizes:
        sizes.write('#include <stdint.h>\n')
        sizes.write('uint32_t pok_elf_sizes[] = {\n')
        for s in source:
            part_size = os.path.getsize(str(s))
            if part_size > pok_env['MAX_PART_SIZE']:
                raise RuntimeError('Partition size must not exceed %d bytes' % pok_env['MAX_PART_SIZE'])
            sizes.write(str(part_size))
            if source.index(s) != len(source) - 1:
                sizes.write(',\n')
        sizes.write('\n};\n')

merge_target = pok_env.Command(target = module_build_dir+'/partitions.bin',
    source = partition_elfs,
    action = merge_partitions)
pok_env.Depends(merge_target, partition_elfs)

merge_file = merge_target[0].abspath

sizes_c_target = pok_env.Command(target = module_build_dir+'/sizes.c',
    source = partition_elfs,
    action = create_sizes_c)
pok_env.Depends(sizes_c_target, partition_elfs)

compile_sizes = pok_env.Command(target = module_build_dir+'/sizes.o',
    source = sizes_c_target,
    action = [
        pok_env['CC']+' -c -o $TARGET '+pok_env['CFLAGS']+' $SOURCE',
        pok_env['OBJCOPY']+' --add-section .archive2='+merge_file+' $TARGET'])
pok_env.Depends(compile_sizes, merge_target)

pok_elf_env = pok_env.Clone()

ldscript_kernel = pok_env['LDSCRIPT_KERNEL']
# Rewrite LINKFLAGS, as we build '.elf'.
pok_elf_env['LINKFLAGS'] = ' -T ' + ldscript_kernel


pok_target = pok_elf_env.Program(target = module_build_dir+'/pok.elf',
    source = compile_sizes + kernel_lo + [pok_env['LIBGCC']])
pok_env.Depends(pok_target, [ldscript_kernel])

pok_target_file = pok_target[0].abspath

# Make string suitable for use in identifier
def str_to_id(s):
    return s.replace('-', '_')

def unsupported_run_command(target, source, env):
    target_path = target[0].abspath
    cmd_begin_index = target_path.rfind('/') + 1
    cmd_end_index = -4 # Cut '_cmd' suffix
    command = target_path[cmd_begin_index:cmd_end_index]
    bsp_id = str_to_id(env['BSP'])
    command_id = str_to_id(command)
    print "ERROR: Command '" + command + "' is unsupported for board " + env['BSP'] + "."
    print "HINT: You may assign script for this command using 'JETOS_" + command_id + "_" + bsp_id + "' environment variable."
    return 1


def define_run_command(command, qemu_action, depends = []):
    bsp_id = str_to_id(env['BSP'])
    command_id = str_to_id(command)
    script = os.environ.get('JETOS_' + command_id + "_" + bsp_id, "")
    if script != "":
        action = script + " " + pok_target_file
    elif env.get('BOARD_IS_EMULATED', False):
        action = qemu_action
    else:
        action = unsupported_run_command

    env.Command(command + '_cmd', depends, action)
    env.Alias(command, command + '_cmd')

env.Append(QEMU_FLAGS = ' -kernel '+pok_target_file)

define_run_command('run',
    '$QEMU $QEMU_FLAGS'
)

define_run_command('run-tap',
    '$QEMU $QEMU_FLAGS  -net nic,model=virtio -net tap,ifname=tap0,script=no,downscript=no'
)

define_run_command('run-tap2',
    '$QEMU $QEMU_FLAGS -net nic,model=virtio,vlan=0 -net nic,model=virtio,vlan=1 -net tap,ifname=tap0,script=no,downscript=no,vlan=0 -net tap,ifname=tap1,script=no,downscript=no,vlan=1'
)

define_run_command('run-tap-ne2k',
    '$QEMU $QEMU_FLAGS -net nic,model=ne2k_pci,vlan=0 -net nic,model=ne2k_pci,vlan=1 -net tap,ifname=tap0,script=no,downscript=no,vlan=0, -net tap,ifname=tap1,script=no,downscript=no,vlan=1'
)

define_run_command('run-gdb',
    '$QEMU $QEMU_FLAGS -serial tcp::8000,server'
)

define_run_command('rundbg',
    '$QEMU $QEMU_FLAGS -S -s'
)

define_run_command('debug',
    '$GDB '+pok_target_file+' -ex "target remote :1234"'
)

define_run_command('debug-gdb',
    '$GDB '+pok_target_file+' -ex "source '+gdb_commands_file+'" -ex "target extended-remote 127.0.0.1:8000"',
    depends = gdb_commands
)

module_clean_dirs = env.get('MODULE_CLEAN_DIRS', module_build_dir)
if type(module_clean_dirs) is not list:
    module_clean_dirs = [module_clean_dirs]
    env['MODULE_CLEAN_DIRS'] = module_clean_dirs


clean_directories = module_clean_dirs + partition_clean_dirs

env.RemoveDirectories('clean_module_cmd', clean_directories)
env.Alias('clean', 'clean_module_cmd')
env.Alias('distclean', 'clean_module_cmd')
env.Clean('#/local', clean_directories)
env.Clean('#/all', clean_directories)

Return('pok_target')

# EOF
