- name: AFDX_FILLER
  additional_h_files: ['"afdx.h"']
  state_struct:
      # vl identificator
        vl_id: uint16_t
        ttl: uint8_t
        src_partition_id: uint8_t
        dst_partition_id: uint8_t
        src_afdx_port: uint16_t
        dst_afdx_port: uint16_t
        sn: uint8_t
        type_of_packet: PACKET_TYPE

  init_func: afdx_filler_init

  in_ports:
      - name: portA
        type: preallocated_sender
        implementation:
           send: afdx_filler_send
           flush: afdx_filler_flush

  out_ports:
       - name: portB
         type: preallocated_sender

- name: AFDX_QUEUE_ENQUEUER
  additional_h_files: ['"afdx.h"', <arinc653/time.h>]
  state_struct:
        BAG: SYSTEM_TIME_TYPE
        buffer: afdx_buffer *
        # the index in the queue for information that should be read
        head: size_t
        # the index in the queue where you want to record information
        tail: size_t
        cur_queue_size: size_t
        max_queue_size: size_t
        #min_next_time: SYSTEM_TIME_TYPE
#temporary solution until we can generate a periodic process components

  init_func: afdx_queue_init

  in_ports:
      - name: portB
        type: preallocated_sender
        implementation:
            send: afdx_enqueuer_implementation
            flush: afdx_enqueuer_flush

  out_ports:
      - name: portNetA
        type: preallocated_sender

      - name: portNetB
        type: preallocated_sender

# for example
- name: AFDX_STOP
  additional_h_files: [<arinc653/time.h>]
  state_struct:
        st: int
  in_ports:
    - name: portA
      type: message_handler
      implementation:
            handle: afdx_stop_func

# receive
- name: AFDX_TIME_ADDER
  additional_h_files: [<arinc653/time.h>]
  state_struct:
        arrival_time: SYSTEM_TIME_TYPE

  init_func: afdx_time_adder_init

  in_ports:
      - name: portB
        type: message_handler
        implementation:
            handle: time_adder_send

  out_ports:
      - name: portA
        type: time_message_handler
        
- name: AFDX_ROUTER
  additional_h_files: ['"router_state_structs.h"']
  state_struct:
      map_vl_id_to_idx[10]: struct vl_index
      map_vl_id_to_idx_len: size_t
  in_ports:
      - name: portA
        type: time_message_handler
        implementation:
            handle: afdx_router_receive_packet

  out_ports:
      - name: portArray
        type: time_message_handler
        is_array: true

- name: INTEGRITY_CHECKER
  additional_h_files: [<types.h>]
  state_struct:
      last_in_seq_number: uint8_t
      first_message_received: pok_bool_t
      network_card: uint8_t

  init_func: integrity_checker_init

  in_ports:
      - name: portA
        type: time_message_handler
        implementation:
            handle: integrity_checker_receive_packet

  out_ports:
      - name: portB
        type: time_message_handler

- name: REDUNDANCY_MANAGER
  additional_h_files: [<types.h>, '"redundancy_manager_struct.h"']
  state_struct:
            arrival_time[SUBNETWORKS_COUNT][MAX_SEQUENCE_NUMBER + 1]: SYSTEM_TIME_TYPE
            virtual_link_data[VIRTUAL_LINKS_COUNT]: vl_data_t

  init_func: redundancy_manager_init

  in_ports:
      - name: portA
        type: time_message_handler
        implementation:
            handle: redundancy_manager_receive_packet_net_a
      - name: portB
        type: time_message_handler
        implementation:
            handle: redundancy_manager_receive_packet_net_b
  out_ports:
      - name: portC
        type: message_handler

- name: AFDX_TO_ARINC_ROUTER
  additional_h_files: [<types.h>]
  state_struct:
            map_afdx_dst_port_to_idx[10]: uint16_t
            map_afdx_dst_port_to_idx_len: size_t

  #init_func: afdx_to_arinc_router_init

  in_ports:
      - name: portC
        type: message_handler
        implementation:
            handle: afdx_to_arinc_router_receive
  out_ports:
      - name: portArray
        type: message_handler
        is_array: true
