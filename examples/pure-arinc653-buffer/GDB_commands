define Push_to_breakpoints_reason
    set breakpoints[Head_of_breakpoints - 1].Reason = $arg0
    end

define Thread_pid
    set $i = 0
    set $V = 0
    while $i < pok_config_nb_partitions
        if pok_partitions[$i].thread_index_high > $arg0 - 1
            set $V = $i + 1
            loop_break
            end
        set $i = $i + 1
        end
    set $PID = $V
    end

define Remove_symbol_file
    if $arg0 > 1
        eval "remove-symbol-file -a 0x%x", pok_partitions[$arg0 - 2].base_vaddr
        end
    end



define Easy_switch
    set $G = $arg0 + 1
    if $OLD_PID != -1
        eval "remove-symbol-file -a 0x%x", pok_partitions[$OLD_PID - 1].base_vaddr
        end
    eval "add-symbol-file pr%d/pr%d.elf 0x%x", $G,$G,pok_partitions[$arg0].base_vaddr
    end


define Switch_to 
    if $arg0 > 0
        set $K = $arg0 - 1
        eval "Easy_switch %d",$K
        set $OLD_PID = $arg0
        end
    end

document Switch_to
Switch to the partition (load symbol-file if it needs)
Syntax: Switch_to PID 
    end

    
    
define Thread_break
    eval "Thread_pid %d",$arg1
    set $V = $PID
    eval "thread %d",$arg1
    eval "Switch_to %d",$V
    eval "set b_need_to_set = 0"
    break $arg0 thread $arg1
    eval "Push_to_breakpoints_reason 2"
    set $V = current_thread + 1
    eval "Thread_pid %d",$V
    set $V = $PID
    eval "Switch_to %d",$V
    eval "thread %d",current_thread + 1
    end

document Thread_break
Set breakpoint on chosen thread
Syntax: Thread_break ADDR THREAD_NUMBER
    end

define Thread_delete
    set $Thread_delete_i = 0
    while (breakpoints[$Thread_delete_i].B_num != $arg0) && ($Thread_delete_i < max_breakpoint)
        set $Thread_delete_i = $Thread_delete_i + 1
        end
    if ($Thread_delete_i < max_breakpoint)
        eval "thread %d",breakpoints[$Thread_delete_i].T_num
        eval "Switch_to %d",breakpoints[$Thread_delete_i].P_num
        eval "set b_need_to_delete = %d",breakpoints[Head_of_breakpoints - 1].B_num
        eval "delete %d",breakpoints[$Thread_delete_i].B_num
        eval "Thread_pid %d",current_thread + 1
        eval "Switch_to %d", $PID
        eval "thread %d",current_thread + 1
        end
    end

document Thread_delete
Delete breakpoint
Syntax: Thread_delete BREAKPOINT_NUMBER
    end

define Clear_breakpoints
    set Head_of_breakpoints = 0
    set last_breakpoint = 0
    set new_start = 1
    end
    
document Clear_breakpoints
Clear breakpoints array and set head_of_breakpoint to zero
Syntax: Clear_breakpoints
end


define connect_to 
    set breakpoint always-inserted on
    set $OLD_PID = -1
    target remote $arg0
    symbol-file pok.elf
    Clear_breakpoints
    end

document connect_to
Use a remote computer via a serial line, using a gdb-specific protocol.
Specify the serial device it is connected to (e.g. /dev/ttyS0, /dev/ttya, COM1, etc.).
Also clear breakpoints array.
Use 'set breakpoint always-inserted on' option.
Syntax: connect_to PORT_ADDR
    end





define hook-stop
    eval "Thread_pid %d",current_thread + 1
    eval "Switch_to %d",$PID
end



define P_break
    set $Part_break_i = 0
    set $Max_part = pok_config_nb_partitions
    if $arg0 > $Max_part
        print "Error, there is no such partition"
        loop_break
    else
        if $arg0 == 0
            set $Part_break_i = pok_partitions[$Max_part - 1].thread_index_high        
            Switch_to $arg0
            while $Part_break_i < pok_config_nb_threads
                eval "thread %d",$Part_break_i + 1
                set $addr = $pc
                if $addr != 0x0
                    if $Part_break_i == pok_config_nb_threads - 3 
                        eval "set b_need_to_set = 0"
                        eval "b monitor thread %d", $Part_break_i + 1
                        eval "Push_to_breakpoints_reason 1"
                    else
                        if $Part_break_i == pok_config_nb_threads - 4
                            eval "set b_need_to_set = 0"
                            eval "b gdb thread %d", $Part_break_i + 1
                            eval "Push_to_breakpoints_reason 1"
                        else
                            eval "set b_need_to_set = 0"
                            eval "b *0x%x thread %d",$addr, $Part_break_i + 1
                            eval "Push_to_breakpoints_reason 1"
                            end
                        end
                    end
                set $Part_break_i = $Part_break_i + 1
                end
            eval "Thread_pid %d",current_thread + 1
            eval "thread %d",current_thread + 1
            eval "Switch_to %d",$PID
            print "Ok on zero part"
            loop_break
        else
            set $Part_break_i = pok_partitions[$arg0 - 1].thread_index_low        
            Switch_to $arg0
            while $Part_break_i < pok_partitions[$arg0 - 1].thread_index_high
                eval "thread %d",$Part_break_i + 1
                set $addr = $pc
                if $addr != 0x0
                    eval "set $V = *((int *) %d)",$pc
                    eval "set b_need_to_set = 0"
                    eval "b *0x%x thread %d",$addr, $Part_break_i + 1
                    eval "Push_to_breakpoints_reason 1"
                    end
                set $Part_break_i = $Part_break_i + 1
                end
            eval "Thread_pid %d",current_thread + 1
            eval "thread %d",current_thread + 1
            eval "Switch_to %d",$PID
             print "Ok on this part"
            end
        end
    end
    

document P_break
Set breakpoints on all partition's threads
Syntax: P_break PID
    end
    
define P_delete
    set $Max_part = pok_config_nb_partitions
    if $arg0 > $Max_part
        print "Error, there is no such partition"
        loop_break
    else
        if Head_of_breakpoints > 0
            if $arg0 > 0
                eval "thread %d",pok_partitions[$arg0 - 1].thread_index_low + 1
                end
            Switch_to $arg0
            while (breakpoints[Head_of_breakpoints - 1].P_num == $arg0) && (Head_of_breakpoints > 0) && (breakpoints[Head_of_breakpoints - 1].Reason == 1)
                eval "set b_need_to_delete = %d",breakpoints[Head_of_breakpoints - 1].B_num
                eval "thread %d",breakpoints[Head_of_breakpoints - 1].T_num
                eval "delete breakpoint %d",breakpoints[Head_of_breakpoints - 1].B_num
                end
            eval "Thread_pid %d",current_thread + 1
            eval "thread %d",current_thread + 1
            eval "Switch_to %d",$PID           
            end
        end
    end
    
document P_delete
Delete breakpoints on all partition's threads. Use it only after break,before adding any breakpoints
Syntax: P_delete PID 
    end    
    
define P_info
    set $P_info_old_pid = -1
    if $argc == 0
        set $P_info_i = pok_config_nb_threads
        while $P_info_i > 0
            eval "Thread_pid %d",$P_info_i
            if $P_info_old_pid != $PID
                eval "Switch_to %d",$PID
                end
            eval "info thread %d",$P_info_i            
            set $P_info_i = $P_info_i - 1
            set $P_info_old_pid = $PID
            end
        eval "Thread_pid %d",current_thread + 1
        if $P_info_old_pid != $PID
            eval "Switch_to %d",$PID
            end
    else
        eval "Thread_pid %d",$arg0
        eval "Switch_to %d",$PID
        eval "info thread %d",$arg0            
        eval "Thread_pid %d",current_thread + 1
        eval "Switch_to %d",$PID
        end
    end
    
document P_info
Print information about all or chosen threads in system. Similar to "info thread", but it loads symbol files.
Syntax: P_info THREAD_NUMBER
    end    

define P_mem
    set $Max_part = pok_config_nb_threads
    if ($arg0 > $Max_part) || ($arg0 < 1)
        print "Error, there is no such thread"
        loop_break
    else
        eval "Thread_pid %d",$arg0
        eval "Thread %d",$arg0
        eval "Switch_to %d",$PID
        if $argc == 2
            $arg1
            end
        if $argc == 3
            $arg1 $arg2
            end
        if $argc == 4
            $arg1 $arg2 $arg3
            end
        if $argc == 5
            $arg1 $arg2 $arg3 $arg4
            end
        eval "Thread_pid %d",current_thread + 1
        eval "Thread %d",current_thread + 1
        eval "Switch_to %d",$PID
        end
    end    

document P_mem
All simple operations. (read/write in memory, info registers, etc.)
Syntax: P_mem THREAD_NUM OPERATIONS ARG1 ARG2 ...

