#pragma once

typedef pok_bool_t jet_bool_t;

struct jet_pt_header_struct;

/** Тип указателя на дерево параметров */
typedef struct jet_pt_header_struct * jet_pt_tree_t;

/** Тип для представления идентификатора узла дерева */
typedef size_t jet_pt_node_t;

/** Недопустимый идентификатор узла дерева */
#define JET_PT_INVALID_NODE (size_t)(-1)

/** Тип узла дерева */
typedef enum {
	JET_PT_STRING,	/**< Узел дерева содержит строковый параметр */
	JET_PT_INTEGER, /**< Узел дерева содержит целочисленный параметр */
	JET_PT_FLOAT,   /**< Узел дерева содержит вещественный параметр */
	JET_PT_TREE,    /**< Узел является промежуточным в дереве. Не содержит значение */
	JET_PT_INVALID_NODE_TYPE /**< Недопустимый тип дерева */
} jet_pt_node_type_t;

/** Возвращает идентификатор корневого узла дерева.
 * 
 * @param tree Указатель на дерево параметров.
 * 
 * @pre tree != NULL
 * @return Идентификатор корневого узла дерева.
 */
jet_pt_node_t jet_pt_root(jet_pt_tree_t tree);

/** Возвращает число дочерних узлов данного узла
 * 
 * 
 * @param tree Указатель на дерево параметров.
 * @param node Узел, для которого возвращается число дочерних узлов.
 * 
 * @pre tree != NULL
 * @return Число дочерних узлов заданного узла. Если идентификатор некорректен 
 * 		или задает листовой узел, возвращается 0.
 */
size_t jet_pt_children_count(jet_pt_tree_t tree, jet_pt_node_t node);

/** Возвращает заданный дочерний узел.
 * 
 * @param tree Указатель на дерево параметров.
 * @param node Узел, для которого возвращается дочерний узел.
 * @param num Номер дочернего узла. Дочерние узлы нумеруются, начиная с 0.
 * 
 * @pre tree != NULL
 * @return Заданный дочерний узел или JET_PT_INVALID_NODE, если задан 
 * 		неверный номер дочернего узла.
 */
size_t jet_pt_get_child(jet_pt_tree_t tree, jet_pt_node_t node, size_t num);

/** Возвращает идентификатор узла дерева по текстовому пути в дереве.
 * 
 * Путь в дереве имеет вид "/a/b/c" или "a/b/c". В первом случае путь рассматривается как абсолютный
 * и разрешается относительно корневого узла, вне зависимости от значения параметра parent. Во втором
 * случае пусть рассматривается как относительный и разрешается относительно узла parent.
 * Знаки слэш (/) разделяют имена промежуточных узлов в пути.
 * 
 * @param tree Указатель на дерево параметров.
 * @param parent Узел, относительно которого ищется путь.
 * @param path Путь в дереве.
 * 
 * @pre tree != NULL
 * @return Идентификатор узла дерева, соответствующего пути, или 
 *   JET_PT_INVALID_NODE если такой узел не существует.
 */
jet_pt_node_t jet_pt_find(jet_pt_tree_t tree, jet_pt_node_t parent, const char * path);

/** Возвращает имя узла.
 * 
 * @param tree Указатель на дерево параметров.
 * @param node Идентификатор узла в дереве.
 * 
 * @pre tree != NULL
 * @return указатель на строку с именем узла, если идентификатор узла корректен, и NULL в противном случае.
 */
const char* jet_pt_get_node_name(jet_pt_tree_t tree, jet_pt_node_t node);

/** Возвращает тип значения, хранящегося в заданном узле.
 * 
 * @param tree Указатель на дерево параметров.
 * @param node Идентификатор узла в дереве.
 * 
 * @pre tree != NULL
 * @return тип содержимого, если идентификатор узла корректен, и JET_PT_INVALID_NODE_TYPE в противном случае.
 */
jet_pt_node_type_t jet_pt_get_node_type(jet_pt_tree_t tree, jet_pt_node_t node);

/** Возвращает строковое значение, хранящееся в узле.
 * 
 * @param tree Указатель на дерево параметров.
 * @param node Идентификатор узла в дереве.
 * @param result указатель на строковый буфер, в который следует записать результат.
 * @param len	указатель на переменную, содержащую размер буфера *result. 
 * 		Если буфер меньше строкового значения, содержащегося в узле дерева, в эту
 * 		переменную будет записан требуемый размер.
 * @pre tree != NULL
 * @pre result != NULL
 * @pre len != NULL
 * 
 * @return 
 *   -- POK_ERRNO_OK если узел является корректным и содержит строковое значение,
 *   -- POK_ERRNO_EINVAL, если узел некорректен или не содержит строковое значение 
 *   (например, является промежуточным узлом или листовым узлом с целочисленным или 
 *   вещественным значением).
 *   -- POK_ERRNO_PARAM, если узел содержит строковое значение, но размер выходного
 *   буфера слишком мал.  В этом случае в переменную *len записывается требуемый 
 *   размер.
 */
pok_ret_t jet_pt_get_string_value(jet_pt_tree_t tree, jet_pt_node_t node, 
	const char ** result, size_t * len);

/** Возвращает размер строкового значения, хранящегося в узле.
 * 
 * @param tree Указатель на дерево параметров.
 * @param node Идентификатор узла в дереве.
 * @param result указатель на переменную, в которую будет записан размер строкового значения.
 * @pre tree != NULL
 * @pre result != NULL
 * 
 * @return 
 *   -- POK_ERRNO_OK если узел является корректным и содержит строковое значение,
 *   -- POK_ERRNO_EINVAL, если узел некорректен или не содержит строковое значение 
 *   (например, является промежуточным узлом или листовым узлом с целочисленным или 
 *   вещественным значением).
 */
pok_ret_t jet_pt_get_string_value_size(jet_pt_tree_t tree, jet_pt_node_t node, 
	size_t * result);

/** Возвращает целое число, хранящееся в узле.
 * 
 * @param tree Указатель на дерево параметров.
 * @param node Идентификатор узла в дереве.
 * @param result указатель на целочисленную переменную, в которую следует записать результат.
 * @pre tree != NULL
 * @pre result != NULL
 * 
 * @return POK_ERRNO_OK если узел является корректным и содержит целочисленное значение,
 *   и POK_ERRNO_EINVAL, если узел некорректен или не содержит целочисленное значение 
 *   (например, является промежуточным узлом или листовым узлом со строковым или 
 *   вещественным значением). 
 */
pok_ret_t jet_pt_get_integer_value(jet_pt_tree_t tree, jet_pt_node_t node, int* result);

/** Возвращает вещественное число, хранящееся в узле.
 * 
 * @param tree Указатель на дерево параметров.
 * @param node Идентификатор узла в дереве.
 * @param result указатель на вещественную переменную, в которую следует записать результат.
 * @pre tree != NULL
 * @pre result != NULL
 * 
 * @return POK_ERRNO_OK если узел является корректным и содержит вещественное значение,
 *   и POK_ERRNO_EINVAL, если узел некорректен или не содержит вещественное значение 
 *   (например, является промежуточным узлом или листовым узлом со строковым или 
 *   целочисленным значением). 
 */
pok_ret_t jet_pt_get_double_value(jet_pt_tree_t tree, jet_pt_node_t node, double* result);

